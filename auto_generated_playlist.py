from typing import Dict, List, Iterable
import utils
from data import Playlist, Track
from copy import deepcopy
import itertools
import re


def get_playlist_name_from_tags(tags: Dict[str, str], tag_keys_order: List[str]) -> str:
    """
    Example: { "genre": "Acid", "rating": "4" } => "ge=Acid ra=4"
    """
    name = ""
    for k in tag_keys_order:
        name += "%s=%s " % (k, tags[k].replace(" ", "_"))
    return name.strip()


def tags_from_playlist_name(playlist_name: str, tag_models: Dict[str, List[str]]):
    matches = re.findall(r'([a-zA-Z0-9_-]+)=([a-zA-Z0-9_-]+)', playlist_name)
    tags = dict()
    for match in matches:
        identified_tag_key = utils.identify_value_from_prefix(match[0], list(tag_models.keys()))
        if identified_tag_key:
            tag_value = match[1].replace("_", " ")
            if tag_value in tag_models[identified_tag_key]:
                tags[identified_tag_key] = tag_value
    return tags


class AutoGeneratedPlaylistManager:

    def __init__(self, tag_models: Dict[str, List[str]], playlists_to_generate: List[List[str]]):
        self._tag_models = tag_models
        self._playlists_to_generate = playlists_to_generate

    def tagged_tracks_from_playlists(self, playlists: List[Playlist]) -> Dict[str, Track]:
        tracks = dict()
        for p in playlists:
            playlist_tags = tags_from_playlist_name(p.name, self._tag_models)
            for t in p.tracks:
                if str(t.path) not in tracks:
                    tracks[str(t.path)] = deepcopy(t)
                playlist_tags.pop("rating", None)
                tracks[str(t.path)].tags.update(playlist_tags)

        return tracks

    def playlists_from_tagged_tracks(self, tracks: Dict[str, Track]) -> List[Playlist]:
        playlists = []
        for tag_keys_index, tag_keys_to_generate_playlist in enumerate(self._playlists_to_generate):
            for tag_values in itertools.product(
                    *[self._tag_models[tag_key] for tag_key in tag_keys_to_generate_playlist]):
                playlist_tags = {tag_keys_to_generate_playlist[i]: tag_values[i] for i, _ in enumerate(tag_values)}
                track_list = []
                for t in tracks.values():
                    if t.tags.items() >= playlist_tags.items():
                        track_list.append(t)
                if not track_list:
                    continue
                playlists.append(Playlist(
                    get_playlist_name_from_tags(playlist_tags, tag_keys_to_generate_playlist),
                    track_list,
                    tag_keys_to_generate_playlist,
                    tag_keys_index + 1
                ))
        return playlists


def merge_playlists(*playlists_lists: Iterable[Playlist]) -> List[Playlist]:
    result = dict()
    for playlist in playlists_lists:
        for p in playlist:
            if p.name in result:
                existing_playlist = result[p.name]
                for t in p.tracks:
                    if not existing_playlist.contains_track(t.path):
                        existing_playlist.tracks.append(deepcopy(t))
            else:
                result[p.name] = deepcopy(p)
    return list(result.values())


if __name__ == "__main__":
    assert get_playlist_name_from_tags({ "genre": "Acid", "rating": "4" }) == "ge=Acid ra=4"
    assert get_playlist_name_from_tags({ "rating": "4", "genre": "Acid" }) == "ge=Acid ra=4"
    assert get_playlist_name_from_tags({ "rating": "4", "genre": "Deep House" }) == "ge=Deep_House ra=4"

    from constants import *
    import json

    with open(SCANNER_TAGS_FILE) as json_file:
        TAGS_MODEL = json.load(json_file)

    assert json.dumps(tags_from_playlist_name("02_RaGe ge=Acid ra=4", TAGS_MODEL)) == json.dumps({'genre2': 'Acid', 'rating': '4'})
    assert json.dumps(tags_from_playlist_name("02_RaGe ge=Deep_House ra=4", TAGS_MODEL)) == json.dumps({'genre2': 'Deep House', 'rating': '4'})
